			      How it Works

Basically, you need to setup two variables that link the lxr url to the
local code base. `lxr-url' should point at the lxr repository and
`lxr-base' should point at the local code base. Both of these variables
are buffer local, since you (well let's face it I) want different
repositories for different directories.

Let's assume you only use lxr for the Linux kernel. One way to
setup lxr would be to add it to your
`c-mode-common-hook'. It would be overkill, but
wouldn't hurt anything since you wouldn't use it outside the kernel.

  (defun lxr-setup ()
    (setq lxr-url "http://lxr.linux.no/"
	  lxr-version "2.6.26"
	  lxr-base (file-truename "/usr/src/linux")))
  (add-hook 'c-mode-common-hook 'lxr-setup)

The `lxr-version' is used by repositories that have multiple versions.
It will default to the most current version if left `nil'.


			      Requirements

  * http.el to grab the lxr file from the url.
  * h2t.el to convert the html to text.
  * For GNU Emacs you need extent.el.
  * And of course, lxr.el!


			     How to Use It

There are currently two main interfaces: web output and definition
files. The web output, `lxr', gives you a text based version of the lxr
web output with clickable links to local files. When you click on a
link, a tag is pushed so you can use `pop-tag-mark' to get back.
`lxr-at-point' is similar except it grabs the word at the point.

Definition files are more like the use in IDEs. With `lxr-defined' you
are prompted for an identifier and then taken to the first file that
matches (if any). `lxr-defined-at-point' is similar except it uses the
word under the point.

In both cases, `lxr-next-defined' can be used to go to the next file in
the list (if any). Again tags are marked so you can pop back through the
list of files.
