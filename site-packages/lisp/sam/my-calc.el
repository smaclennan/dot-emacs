;;; my-calc.el --- A simple calculator

;; Copyright (C) 1997-2010 Sean MacLennan
;; Revision:   1.7

;;{{{ License agrement

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;;}}}

;;{{{ Commentary

;; This package implements a simple calculator. It understands most of
;; the 'C' operators and the order of operation. It also does hex to/from
;; decimal conversions.

;; The calculator is based on the operator-precedence parsing algorithm
;; from "Compilers Principles, Techniques, and Tools"
;; by Alfred V. Aho, Ravi Sethi, and Jeffery D. Ullman.

;;}}}

;;{{{ Installation

;; Up until 1.7 (Feb 2010), this provided calc. I renamed it to
;; my-calc so I could use the standard calc package.

;; (require 'my-calc)

;;}}}

;;{{{ Code

(provide 'my-calc)

(defconst my-calc-f-values
  '((?*  . 12) (?/  . 12) (?% . 12)
    (?+  . 10) (?-  . 10)
    (?<  .  8) (?>  .  8)
    (?&  .  6) (?^  .  4) (?| .  2)
    (?\( .  0) (?\) . 14)
    (?N  . 14)			; number
    (?=  .  0))			; terminator
  "Values for the precedence function `f'.")

(defconst my-calc-g-values
  '((?*  . 11) (?/  . 11) (?% . 11)
    (?+  .  9) (?-  .  9)
    (?<  .  7) (?>  .  7)
    (?&  .  5) (?^  .  3) (?| .  1)
    (?\( . 13) (?\) .  0)
    (?N  . 13)			; number
    (?=  .  0))			; terminator
  "Values for the precedence function `g'.")

(defconst my-calc-commands
  '((?* . *) (?/ . my-calc-div) (?% . mod)
    (?+ . +) (?- . -)
    (?< . ash) (?> . rash)
    (?& . logand) (?^ . logeor) (?| . logior))
  "Command char to lisp command")

;; From stack-f.el. Trying to require stack-f just causes too much grief.

(defun stack-create ()
  "Create an empty lifo stack."
  (cons 'STACK nil))

(defun stack-push (stack element)
  "Push an element onto the stack."
  (setcdr stack (cons element (cdr stack))))

(defun stack-pop (stack)
  "Remove the topmost element from STACK and return it.
If the stack is empty, return nil."
  (prog1
      (car-safe (cdr stack))
    (setcdr stack (cdr-safe (cdr stack)))))

(defun stack-top (stack)
  "Return the topmost element of STACK or nil if it is empty."
  (car-safe (cdr stack)))

(defun stack-clear (stack)
  "Remove all elements from STACK."
  (setcdr stack nil))

;; End of stack-f.el

(defvar calc-nums (stack-create)
  "Internal stack of numbers")

(defun rash (a b)
  (ash a (- 0 b)))

(defvar my-calc-int-divides nil
  "* If nil, divides are always floating point.")

;; I find I almost always want floating point for divides.
(defun my-calc-div (a b)
  (if my-calc-int-divides
      (/ a b)
    (/ (float a) (float b))))

(defun my-calc-f (cmd)
  "Precedence function `f'."
  (let ((lookup (cdr (assoc cmd my-calc-f-values))))
    (if lookup
	lookup
      (error "Syntax error"))))

(defun my-calc-g (cmd &optional number)
  "Precedence function `g'."
  ;; Only the `g' function is ever looking at a number.
  ;; It reads the number, pushes it on the calc-nums stack,
  ;; and replaces the number with the token `N' in the buffer.
  (if (and number (setq number (my-calc-get-number)))
      (progn
	;; Push on calc-nums stack
	(stack-push calc-nums number)
	;; Replace number with token
	(replace-match "N")
	(forward-char -1)
	;; Lookup N below.
	(setq cmd ?N)))

  (let ((lookup (cdr (assoc cmd my-calc-g-values))))
    (if lookup
	lookup
      (error "Syntax error"))))

(defun my-calc-get-number ()
  "Read the next number in the buffer and returns the number or nil.
Handles hex/float/integer."
  (cond
   ;; Hex?
   ((looking-at "$?\\(0[0-9a-fA-F]+\\)$?")
    (string-to-number (match-string 1) 8))
   ((looking-at "$?\\(0[xX]\\)\\([0-9a-fA-F]+\\)$?")
    (string-to-number (match-string 2) 16))
   ;; Integer/float?
   ((looking-at "$?\\([0-9]*\\.?[0-9]+\\)$?")
    (string-to-number (match-string 1)))
   ;; Negative hex?
   ;; The preceding token must be an op (not a number)
   ((and (looking-at "$?-\\(0[xX]\\)\\([0-9a-fA-F]+\\)$?")
	 (or (not (eq (preceding-char) ?N)) (bobp)))
    (- 0 (string-to-number (match-string 2) 16)))
   ;; Negative integer/float?
   ;; The preceding token must be an op (not a number)
   ((and (looking-at "$?\\(-[0-9]*\\.?[0-9]+\\)")
	 (or (not (eq (preceding-char) ?N)) (bobp)))
    (string-to-number (match-string 1)))
   (t nil)))

(defun my-calc-comma (n)
  (let (s)
    (while (>= (abs n) 1000)
      (setq s (concat (format ",%03d" (mod (abs n) 1000)) s))
      (setq n (/ n 1000)))
    (setq s (concat (number-to-string n) s))
    s))

(defun my-calc-float-comma (f)
  (let ((in (format "%g" f)) s)
    (when (string-match "^-?[0-9]+" in)
      (setq s (my-calc-comma (string-to-number (match-string 0 in)))))
    (when (string-match "\\.[0-9]+" in)
      (setq s (concat s (match-string 0 in))))
    s))

;;;###autoload
(defun my-calc (command)
  "Simple calculator.

Supports the following operations:
	( )	grouping
	* / %	multiplication, division, modulo
	+  -	addition and subtraction
	<< >>	arithmetic shift left and right
	&	bitwise and
	^	bitwise exclusive or
	|	bitwise or

Numbers are as follows:
	0N      is an octal (base 8) number
	[-]0xN	is a hex (base 16) number
	[-]N.N	is a floating point number
	[-]N	is an integer

	Commas are allowed; as are a $ at the start or end of a number.

Output goes to the *calc* buffer and the echo line."
  (interactive "sCalc: ")
  (save-current-buffer
    (set-buffer (get-buffer-create "*calc*"))
    (save-restriction
      (narrow-to-region (point-max) (point-max))
      (insert command)
      (insert ?=)			; mark end of command

      ;; Remove all white space, commas, and Ns
      (goto-char (point-min))
      (while (re-search-forward "[ \tN,]" nil t) (replace-match ""))
      (goto-char (point-min))		; go back to start

      (let (ops cmd result one two func)

	(stack-clear calc-nums)
	(setq ops (stack-create))
	(stack-push ops ?=)

	;; Continue until all input parsed and command stack empty.
	(while (or (not (eq (following-char) ?=)) (not (eq (stack-top ops) ?=)))

	  ;; special case for two char tokens `>>' and `<<'
	  (if (looking-at "\\(<<\\)\\|\\(>>\\)") (forward-char))

	  ;; process a command char
	  (if (<= (my-calc-f (stack-top ops)) (my-calc-g (following-char) t))
	      ;; shift
	      (progn
		(stack-push ops (following-char))
		(if (not (eq (following-char) ?=)) (forward-char)))
	    ;; reduce
	    (while
		(progn
		  ;; Pop the top command.
		  (setq cmd (stack-pop ops))

		  (when (setq func (cdr (assoc cmd my-calc-commands)))
		    ;;Perform operation and push result
		    ;; All commands take two numbers
		    (setq two (stack-pop calc-nums))
		    (setq one (stack-pop calc-nums))
		    (stack-push calc-nums (apply func one two nil)))

		  ;; Until
		  (>= (my-calc-f (stack-top ops)) (my-calc-g cmd))))))

	;; Done! Put the result in both the *calc* buffer and the echo area.
	(delete-region (point-min) (point-max))
	(setq result (stack-pop calc-nums))
	(cond ((integerp result)
	       (insert (format "%s = %d (%x %o)\n" command result result result))
	       (message "%s (%x %o)"  (my-calc-comma result) result result))
	      ((floatp result)
	       (insert (format "%s = %g\n" command result))
	       (message "%s" (my-calc-float-comma result)))
	      (t	;; Huh? Should be integer or float...
	       (insert (format "%s = ?%S?\n" command result))
	       (message "?%S?" result)))))))

;;}}}

;;; my-calc.el ends here
