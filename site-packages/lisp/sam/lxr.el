;;; lxr.el --- XEmacs interface to lxr source browser

;; Copyright (C) 2000-2009 Sean MacLennan
;; Revision:   1.3
;; XEmacs/Emacs

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;; For Linux Kernel
;; (setq lxr-url "http://lxr.linux.no"
;;       lxr-version "2.4.0"
;;       lxr-base (file-truename "/usr/src/linux")

(defvar lxr-url nil
  "*URL to use for lxr")
(make-variable-buffer-local 'lxr-url)

(defvar lxr-version nil
  "*Version string for lxr or nil for default")
(make-variable-buffer-local 'lxr-version)

(defvar lxr-arch nil
  "*Architecture for lxr or nil for default.
You should never need to set this....")
(make-variable-buffer-local 'lxr-arch)

(defvar lxr-base nil
  "*Base for lxr files")
(make-variable-buffer-local 'lxr-base)

(defvar lxr-keymap nil
  "Keymap for lxr buffer.")

(defvar lxr-defined-alist nil
  "Local variable with alist of files and line numbers.")

;; SAM This forces lxr to be single threaded
(defvar lxr-local-base nil "Local variable")

;; Minor mode
(defvar lxr-mode-hook nil)
(defvar lxr-mode-on-hook nil)
(defvar lxr-mode-off-hook nil)

(define-minor-mode lxr-mode
  "Minor mode for LXR buffer."
  nil " LXR" lxr-keymap)
;; Minor mode

(provide 'lxr)

(require 'sam-common)
(require 'http)
(require 'h2t)
(require 'etags)
(require 'trim)


(my-feature-cond
  (xemacs
   (defalias 'read-only-mode 'toggle-read-only))
  (emacs
   (require 'ring)
   (require 'extent)

   (defun push-tag-mark ()
     (let ((marker (make-marker)))
       (set-marker marker (point))
       (ring-insert find-tag-marker-ring marker)))

   (defsubst region-exists-p () mark-active)
   ))


(defun lxr-word-at-point ()
  "Get the word at the point. Use the region if it exists."
  (if (region-exists-p)
      (buffer-substring (region-beginning) (region-end))
    (current-word)))

;;;###autoload
(defun lxr-at-point ()
  (interactive)
  (lxr (lxr-word-at-point)))

;;;###autoload
(defun lxr-defined (ident)
  (interactive "sIdentifier: ")
  (lxr ident 'lxr-defined-sentinel))

;;;###autoload
(defun lxr-defined-at-point ()
  (interactive)
  (lxr-defined (lxr-word-at-point)))

;;;###autoload
(defun lxr-next-defined ()
  (interactive)
  (unless lxr-defined-alist (error "No more files."))
  (let* ((list (pop lxr-defined-alist))
	 (file (nth 0 list))
	 (line (nth 1 list)))
    (push-tag-mark)
    (find-file file)
    (goto-char 0)
    (forward-line (1- line))))

(defun lxr-make-keymap ()
  (unless lxr-keymap
    (setq lxr-keymap (make-sparse-keymap "lxr"))
    (my-feature-cond
      (xemacs
       (define-key lxr-keymap 'button1 'lxr-mousable)
       (define-key lxr-keymap 'button2 'lxr-mousable))
      (emacs
       (define-key lxr-keymap [mouse-1] 'lxr-mousable)
       (define-key lxr-keymap [mouse-2] 'lxr-mousable)))
    (define-key lxr-keymap "\C-m" 'lxr-keystroke)
    (define-key lxr-keymap "g" 'lxr-keystroke)))

;;;###autoload
(defun lxr (ident &optional sentinel)
  (interactive "sIdentifier: ")
  (unless lxr-url (setq lxr-url (read-string "lxr url: ")))
  (unless lxr-base (setq lxr-base (read-string "lxr base: ")))
  (unless lxr-keymap (lxr-make-keymap))
  (unless sentinel (setq sentinel 'lxr-get-sentinel))
  (let ((buf (get-buffer "*lxr*"))
	(cur (current-buffer)))
    (when buf
      (set-buffer buf)
      (read-only-mode 0)
      (set-buffer cur)))
  (let ((url (concat lxr-url "/ident?"
		     (if lxr-version (concat "v=" lxr-version ";"))
		     (if lxr-arch (concat "a=" lxr-arch ";"))
		     "i=" ident)))
    (http-get-page url "*lxr*" sentinel))
  (setq lxr-local-base lxr-base) ;; lxr-base is buffer local
  (when (eq sentinel 'lxr-get-sentinel)
    (pop-to-buffer "*lxr*")))

(defun lxr-specific-cleanup ()
  (trim-lines)

  ;; Remove the trailer. Everything from "This page was" on.
  (when (re-search-forward "[ \t\n]*This page was automatically generated by" nil t)
    (goto-char (match-beginning 0)) (forward-char) ;; do not delete \n
    (kill-region (point) (point-max)))

  ;; Remove the header. The header is all the text from the start of
  ;; the buffer to the first word after "Cross Reference"
  (goto-char (point-min))
  (when (re-search-forward "Cross Reference[ \t\n]*" nil t)
    (kill-region (point-min) (match-end 0)))
  )

(defun lxr-get-sentinel (proc str)
  ;; First make sure the http command succeeded
  (let ((buffer (process-buffer proc)))
    (set-buffer buffer)
    (goto-char (point-min))
    (unless (looking-at "HTTP/[1-9]\\.[0-9]+ 200")
      ;; http error
      (error "http request failed: %s"
	     (buffer-substring (point-min) (progn (end-of-line) (point)))))

    ;; stip the server header
    (if (search-forward-regexp "^[ \t\r]*\n" nil t)
	(delete-region (point-min) (point)))

    (unless (string-match "/$" lxr-local-base)
      (setq lxr-local-base (concat lxr-local-base "/")))

    ;; Convert the page to text
    (set-buffer-modified-p nil)
    (html-to-text buffer lxr-keymap t)
    (lxr-specific-cleanup)
    (setq lxr-mode t)
    (set-buffer-modified-p nil)
    (read-only-mode 1)
    )
  (message "Done"))

(defun lxr-defined-sentinel (proc str)
  (save-current-buffer
    (set-buffer (process-buffer proc))
    ;; First make sure the http command succeeded
    (goto-char (point-min))
    (unless (looking-at "HTTP/[1-9]\\.[0-9]+ 200")
      ;; http error
      (error "http request failed: %s"
	     (buffer-substring (point-min) (progn (end-of-line) (point)))))

    (unless (string-match "/$" lxr-local-base)
      (setq lxr-local-base (concat lxr-local-base "/")))

    ;; Isolate the "Defined as" list.
    (unless (re-search-forward "Defined as a [a-z ]+ in:<ul>" nil t)
      (error "Not defined."))
    (kill-region (point-min) (match-end 0))
    (unless (re-search-forward "</ul>")
      (error "Missing </ul>"))
    (kill-region (match-beginning 0) (point-max))

    ;; Now find all the files.
    (let (file line count)
      (setq lxr-defined-alist nil) ;; clear out old list
      (goto-char (point-min))
      (while (re-search-forward "<li>" nil t)
	;; Fail if we don't match - I want to catch misformed lines
	(re-search-forward "<a href=[^>]+>\\([^,]+\\), line \\([0-9]+\\)</a>")
	(setq file (concat lxr-local-base (match-string 1))
	      line (string-to-number (match-string 2)))
	(push (list file line) lxr-defined-alist))
      (setq count (length lxr-defined-alist))
      (if (eq count 1)
	  (message "Found file.")
	(message "Found %d files." count)))
    ) ;; out of save-excursion

  (lxr-next-defined))

;; Find the extent nearest pos. Can return nil.
(defun lxr-nearest-extent (pos)
  (let ((extent (extent-at pos)))
    (unless extent
      (setq extent (extent-at (next-extent-change pos)))
      (unless extent
	(setq extent (extent-at (previous-extent-change pos)))
	))
    extent))

(defun lxr-doit (pos)
  (let* ((extent (lxr-nearest-extent pos))
	 (anchor (extent-property extent 'anchor))
	 line file)
    (cond
     ;; source file
     ;; source/kernel/daytona/daytona.c?v=git-monza#L172
     ((string-match (concat "^source/"
			    "\\([^#?]+\\)"
			    "\\(\\?v=[^#?]+\\)?"
			    "\\(\\?a=[^#?]+\\)?"
			    "#L\\([0-9]+\\)")
		    anchor)
      (setq line (string-to-number (match-string 4 anchor)))
      (setq file (concat lxr-local-base (match-string 1 anchor)))
      (push-tag-mark)
      (find-file file)
      (goto-char 0)
      (forward-line (1- line)))

     ;; ident (e.g. class reference)
     ((string-match "^ident" anchor)
      (http-get-page (concat lxr-url "/" anchor) "*lxr*" 'lxr-get-sentinel)
      (pop-to-buffer "*lxr*"))

     ;; generic http (e.g. lxr reference in trailer)
     ((string-match "^http:.*" anchor)
      (browse-url (match-string 0 anchor)))

     ;; huh?
     (t (error "Unknown anchor '%S'" anchor)))
    ))

;; This is called on a mouse click
(defun lxr-mousable (event)
  (interactive "e")
  (lxr-doit (event-point event)))

;; This is called from a keystroke
(defun lxr-keystroke ()
  (interactive)
  (lxr-doit (point)))

