(provide 'git-diff)

(eval-when-compile
  (require 'cl)
  (require 'ediff)
  (unless (fboundp 'region-exists-p)
    (defsubst region-exists-p () mark-active)))

(defun git-dir (&optional dir)
  "Find the base git directory. If DIR is nil, `default-directory' is used."
  (unless dir (setq dir default-directory))
  ;; Sanitize the directory
  (setq dir (expand-file-name (file-name-as-directory dir)))
  (catch 'found
    (while (not (equal dir "/"))
      (when (file-exists-p (concat dir "/.git"))
	(throw 'found dir))
      ;; This removes the last directory
      (setq dir (file-name-directory (directory-file-name dir))))
    (error "No git base.")))

(defun git-cat-doit (&optional rev buf)
  "Perform a git cat on the current buffer into a temporary buffer.
If `rev' is not set, default is HEAD."
  (let* ((full-path (buffer-file-name))
	 ;; git-fname must be relative to git base
	 (git-fname (substring full-path (length (git-dir))))
	 (fname (file-name-nondirectory full-path))
	 (catname (concat rev ":" git-fname)))
    (unless buf
      (setq buf (get-buffer-create (concat "*" fname "*"))))
    (with-current-buffer buf
      (erase-buffer)
      (call-process "git" nil buf nil "show" catname)
      (set-buffer-modified-p nil))
    buf))

;;;###autoload
(defun git-cat (rev)
  "Perform a git cat on the current buffer into a temporary buffer.
If a prefix arg is specified, ask for the revision. Default is HEAD.
The name of the temporary buffer will be displayed."
  (interactive "P")
  (and rev (listp rev) ;; prefix arg
       (setq rev (read-from-minibuffer "Revision: ")))
  (message "git cat to buffer %s" (buffer-name (git-cat-doit rev))))

;;;###autoload
(defun git-ediff (rev)
  "Perform a git diff against the current buffer using ediff.
With a prefix arg, ask for the revision. Otherwise defaults to HEAD."
  (interactive "P")
  (when rev
    (setq rev (read-from-minibuffer "Revision: ")))
  (ediff-buffers (current-buffer) (git-cat-doit rev)))

;;;###autoload
(defalias 'git-diff 'git-ediff)

;;;###autoload
(defun git-status ()
  (interactive)
  (let ((buf (get-buffer-create "*git status*")))
    (call-process "git" nil buf nil "status")))

;;;------ git grep

(defvar git-grep-top-of-tree t
  "*If non-nil, start grep at top of tree.")

(defvar git-grep-args "--no-color -n"
  "*Default args to git grep.")

(defun git-grep-doit (str)
  "Internal routine to perform the grep."
  (if (not (featurep 'xemacs)) (require 'grep))
  (let ((grep-null-device nil) ;; XEmacs
	(grep-use-null-device nil)) ;; Emacs
    (grep (concat "git grep " git-grep-args " '" str "' | cat"))))

;;;###autoload
(defun git-grep (arg str)
  "Run git grep, with user-specified regular expression, and collect
output in a buffer.  While grep runs asynchronously, you can use the
\\[next-error] command to find the text that grep hits refer to.

If `git-grep-top-of-tree' is non-nil, then the grep starts at the top
of the git dir. Else it starts at the current directory. A prefix arg
disables `git-grep-top-of-tree'."
  (interactive "P\nsRegexp: ")
  (if (and (not arg) git-grep-top-of-tree)
      (let ((default-directory (git-dir)))
	(git-grep-doit str))
    (git-grep-doit str)))

;;;###autoload
(defun git-grep-at-point (arg)
  "Perform a `git-grep' with the word the point is on. If a region
exists, that is used rather than the current word. ARG has the same
meaning as in `git-grep'."
  (interactive "P")
  (let ((word (if (region-exists-p)
		  (buffer-substring (region-beginning) (region-end))
		(current-word))))
    (git-grep arg word)))
