(provide 'git-diff)

(require 'sam-common)

(eval-when-compile (require 'cl) (require 'ediff))

(defun git-fname (path)
  "Given a full file path, return the path relative to the .git
directory and the top-level path."
  (let (git-fname)
    (catch 'found
      (while t
	(unless (string-match "\\(.*\\)/\\([^/]+\\)$" path)
	  (error "No git base found"))
	(if git-fname
	    (setq git-fname (concat (match-string 2 path) "/" git-fname))
	  (setq git-fname (match-string 2 path)))
	(setq path (match-string 1 path))
	(when (file-exists-p (concat path "/.git"))
	  (throw 'found (list git-fname path)))))))

(defun git-cat (&optional rev)
  "Perform a git cat on the current buffer into a temporary buffer.
If a prefix arg is specified, ask for the revision. Default is HEAD.
When called interactively, the name of the temporary buffer will be displayed."
  (interactive "P")
  (and rev (is-interactive)
       (setq rev (read-from-minibuffer "Revision: ")))
  (let* ((full-path (buffer-file-name))
	 (git-fname (car (git-fname full-path)))
	 (fname (file-name-nondirectory full-path))
	 (buf (get-buffer-create (concat "*" fname "*")))
	 (catname (concat rev ":" git-fname)))
    (save-current-buffer
      (set-buffer buf) ;; really for GNU Emacs
      (erase-buffer)
      (call-process "git" nil buf nil "show" catname)
      (set-buffer-modified-p nil)
      (when (is-interactive)
	(message "git cat to buffer %s" (buffer-name buf))))
    buf))

;;;###autoload
(defun git-ediff (rev)
  "Perform a git diff against the current buffer using ediff.
With a prefix arg, ask for the revision. Otherwise defaults to HEAD."
  (interactive "P")
  (when (and (is-interactive) rev)
    (setq rev (read-from-minibuffer "Revision: ")))
  (let ((buf (git-cat rev)))
    (ediff-buffers (current-buffer) buf)))

;;;###autoload
(defalias 'git-diff 'git-ediff)

;;;###autoload
(defun git-status ()
  (interactive)
  (let ((buf (get-buffer-create "*git status*")))
    (call-process "git" nil buf nil "status")))

;;;------ git grep

(defvar git-grep-top-of-tree t
  "*If non-nil, start grep at top of tree.")

(defvar git-grep-args "--no-color -n"
  "*Default args to git grep.")

(defun git-grep-doit (str)
  "Internal routine to perform the grep."
  (let ((grep-null-device nil) ;; XEmacs
	(grep-use-null-device nil)) ;; Emacs
    (grep (concat "git grep " git-grep-args " '" str "' | cat"))))

;;;###autoload
(defun git-grep (str)
  "Run git grep, with user-specified regular expression, and collect
output in a buffer.  While grep runs asynchronously, you can use the
\\[next-error] command to find the text that grep hits refer to."
  (interactive "sRegexp: ")
  (if git-grep-top-of-tree
      (let ((default-directory (nth 1 (git-fname buffer-file-name))))
	(git-grep-doit str))
    (git-grep-doit str)))

;;;###autoload
(defun git-grep-at-point ()
  (interactive)
  (let ((word (if (region-exists-p)
		  (buffer-substring (region-beginning) (region-end))
		(current-word))))
    (git-grep word)))

;; (global-set-key [f11] 'git-grep)
