;;; ogrok.el --- Emacs interface to OpenGrok source browser

;; Copyright (C) 2017 Sean MacLennan
;; Revision:   0.1
;; XEmacs/Emacs

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;; This is a very crude interface to OpenGrok.

(defvar ogrok-url nil
  "*URL to use for opengrok")

(defvar ogrok-project nil
  "*Project to use with opengrok. Must be set.")

(defvar ogrok-xref "/xref/"
  "*opengrok xref prefix.")

(defvar ogrok-path nil
  "*Optional path argument to opengrok.")

(defvar ogrok-base nil
  "*Local base for opengrok files")

(provide 'ogrok)

(require 'http)
(require 'compile)

;;;###autoload
(defun ogrok-at-point ()
  (interactive)
  (ogrok (current-word)))

;;;###autoload
(defun ogrok (ident)
  (interactive "sIdentifier: ")
  ;; SAM bug - currently GNU Emacs only :(
  (when running-xemacs (error "Not supported on XEmacs."))
  (unless ogrok-url (setq ogrok-url (read-string "url: ")))
  (unless ogrok-project (setq ogrok-project (read-string "project: ")))
  (unless ogrok-base (setq ogrok-base (read-string "local base: ")))
  (let ((buf (get-buffer "*ogrok*")))
    (when buf
      (save-current-buffer
	(set-buffer buf)
	(setq buffer-read-only nil))))
  (let ((url (concat ogrok-url "/search?q=&defs=" ident
		     "&refs=&path=" ogrok-path
		     "&hist=&type=&project=" ogrok-project)))
    (http-get-page url "*ogrok*" 'ogrok-sentinel)
    (display-buffer "*ogrok*")
    ))

(defun ogrok-strip-tags (line)
  (while (string-match "<[^>]+>" line)
    (setq line (replace-match "" nil nil line)))
  (when (string-match "^[ \t]+" line)
    (setq line (replace-match "" nil nil line)))
  line)

(defun ogrok-filename-func (filename)
  (concat ogrok-base "/" filename))

(defun ogrok-sentinel (proc str)
  ;; First make sure the http command succeeded
  (let ((buffer (process-buffer proc))
	(compilation-parse-errors-filename-function 'ogrok-filename-func)
	ogrok-list more this regex)
    (set-buffer buffer)
    (goto-char (point-min))
    (unless (looking-at "HTTP/[1-9]\\.[0-9]+ 200")
      ;; http error
      (error "http request failed: %s"
	     (buffer-substring (point-min) (progn (end-of-line) (point)))))

    ;; Isolate the <div id="results">
    (when (search-forward "<div id=\"results\">" nil t)
      (delete-region (point-min) (point)))
    (when (search-forward "</div>" nil t)
      (delete-region (point) (point-max)))

    ;; More?
    (goto-char (point-min))
    (when (search-forward "class=\"more\"" nil t)
      (setq more t))

    ;; Get all the hrefs
    (goto-char (point-min))
    (setq regex (concat "class=\"s\" href=\"" ogrok-xref "\\([^#]+\\)#\\([0-9]+\\)\">"))
    (while (re-search-forward regex nil t)
      (setq this (list (match-string 1) (match-string 2)))
      (when (looking-at "<span class=\"l\">[0-9]+</span>")
	(goto-char (match-end 0)))
      (when (re-search-forward ".+?<br/>" nil t) ;; non-greedy match
	(nconc this (list (ogrok-strip-tags (match-string 0)))))
      (setq ogrok-list (nconc ogrok-list (list this))))

    ;; Fixup the buffer and parse it
    (erase-buffer)
    (insert (concat "-*- mode: compilation; default-directory: \"" ogrok-base "\" -*-\n"))
    (dolist (file ogrok-list)
      (insert (format "%s:%s:1:" (car file) (cadr file)))
      (when (eq (length file) 3) (insert (concat " " (nth 2 file))))
      (insert "\n"))
    (when more (insert "\nMore...\n"))
    (compilation-mode "ogrok")
    (setq buffer-read-only nil)
    (compilation--parse-region (point-min) (point-max))
    (setq buffer-read-only t)
    (goto-char (point-min))
    )
  (message "Done"))
