;;; ogrok.el --- Emacs interface to OpenGrok source browser

;; Copyright (C) 2017 Sean MacLennan
;; Revision:   0.1
;; XEmacs/Emacs

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;; This is a very crude interface to OpenGrok. I am not very proud of
;; it, but it kinda works.

(defvar ogrok-url nil
  "*URL to use for opengrok")

(defvar ogrok-project nil
  "*Project to use with opengrok. Must be set.")

(defvar ogrok-base nil
  "*Local base for opengrok files")

(defvar ogrok-path nil
  "*Optional path argument to opengrok.")

(defvar ogrok-keymap nil
  "Keymap for ogrok buffer.")

;; Minor mode
(defvar ogrok-mode-hook nil)
(defvar ogrok-mode-on-hook nil)
(defvar ogrok-mode-off-hook nil)

(define-minor-mode ogrok-mode
  "Minor mode for OGROK buffer."
  nil " grok" ogrok-keymap)
;; Minor mode

(provide 'ogrok)

(my-feature-cond
  (xemacs
   (defalias 'read-only-mode 'toggle-read-only))
  (emacs
   (require 'ring)

   (defsubst region-exists-p () mark-active)

   (defun push-tag-mark ()
     (let ((marker (make-marker)))
       (set-marker marker (point))
       (my-feature-cond
	 (xref-push-marker-stack
	  (xref-push-marker-stack marker))
	 (t
	  (ring-insert find-tag-marker-ring marker)))))
   ))

(defun ogrok-word-at-point ()
  "Get the word at the point. Use the region if it exists."
  (if (region-exists-p)
      (buffer-substring (region-beginning) (region-end))
    (current-word)))

;;;###autoload
(defun ogrok-at-point ()
  (interactive)
  (ogrok (ogrok-word-at-point)))

;;;###autoload
(defun ogrok-next-defined ()
  (interactive)
  (set-buffer "*ogrok*")
  (forward-line)
  (ogrok-doit (point)))

(defun ogrok-make-keymap ()
  (unless ogrok-keymap
    (setq ogrok-keymap (make-sparse-keymap "ogrok"))
    (my-feature-cond
      (xemacs
       (define-key ogrok-keymap 'button1 'ogrok-mousable)
       (define-key ogrok-keymap 'button2 'ogrok-mousable))
      (emacs
       (define-key ogrok-keymap [mouse-1] 'ogrok-mousable)
       (define-key ogrok-keymap [mouse-2] 'ogrok-mousable)))
    (define-key ogrok-keymap "\C-m" 'ogrok-keystroke)
    (define-key ogrok-keymap "g" 'ogrok-keystroke)))

;;;###autoload
(defun ogrok (ident &optional sentinel)
  (interactive "sIdentifier: ")
  (unless ogrok-url (setq ogrok-url (read-string "ogrok url: ")))
  (unless ogrok-project (setq ogrok-project (read-string "ogrok project: ")))
  (unless ogrok-keymap (ogrok-make-keymap))
  (unless sentinel (setq sentinel 'ogrok-get-sentinel))
  (let ((buf (get-buffer "*ogrok*"))
	(cur (current-buffer)))
    (when buf
      (set-buffer buf)
      (read-only-mode 0)
      (set-buffer cur)))
  (let ((url (concat ogrok-url "/search?q=&defs=" ident
		     "&refs=&path=" ogrok-path
		     "&hist=&type=&project=" ogrok-project)))
    (http-get-page url "*ogrok*" sentinel)
    (when (eq sentinel 'ogrok-get-sentinel)
      (pop-to-buffer "*ogrok*"))
    ))

(defun ogrok-filename-func (filename)
  (concat ogrok-base "/" filename))

(defun ogrok-get-sentinel (proc str)
  ;; First make sure the http command succeeded
  (let ((buffer (process-buffer proc))
	(compilation-parse-errors-filename-function 'ogrok-filename-func)
	ogrok-alist more)
    (set-buffer buffer)
    (goto-char (point-min))
    (unless (looking-at "HTTP/[1-9]\\.[0-9]+ 200")
      ;; http error
      (error "http request failed: %s"
	     (buffer-substring (point-min) (progn (end-of-line) (point)))))

    ;; Isolate the <div id="results">
    (when (search-forward "<div id=\"results\">" nil t)
      (delete-region (point-min) (point)))
    (when (search-forward "</div>" nil t)
      (delete-region (point) (point-max)))

    ;; More?
    (goto-char (point-min))
    (when (search-forward "class=\"more\"" nil t)
      (setq more t))

    ;; Get all the hrefs
    (goto-char (point-min))
    (setq ogrok-defined-alist '())
    (while (re-search-forward "class=\"s\" href=\"/xref/\\([^#]+\\)#\\([0-9]+\\)" nil t)
      (push (list (match-string 1) (match-string 2)) ogrok-alist))

    (erase-buffer)
    (insert (concat "-*- mode: compilation; default-directory: \"" ogrok-base "\" -*-\n"))
    (dolist (file ogrok-alist)
      (insert (format "%s:%s:1:\n" (car file) (cadr file))))
    (when more (insert "\nMore...\n"))
    (compilation--parse-region (point-min) (point-max)) ;; SAM
    (goto-char (point-min))
    )
  (message "Done"))

(defun testit ()
  (interactive)
  (let ((compilation-parse-errors-filename-function 'ogrok-filename-func))
    (compilation-setup)
    (compilation--parse-region (point-min) (point-max)) ;; SAM
    ))

(defun ogrok-doit (pos)
  (let (line file)
    (goto-char pos)
    (beginning-of-line)
    (when (looking-at "^\\(/.*\\)#\\([0-9]+\\)$")
      (setq file (concat ogrok-base (match-string 1)))
      (setq line (string-to-number (match-string 2)))
      (if (file-exists-p file)
	  (progn
	    (push-tag-mark)
	    (find-file file)
	    (goto-char 0)
	    (forward-line (1- line)))
	(error "%s does not exist" file))
      )))

;; This is called on a mouse click
(defun ogrok-mousable (event)
  (interactive "e")
  (ogrok-doit (event-point event)))

;; This is called from a keystroke
(defun ogrok-keystroke ()
  (interactive)
  (ogrok-doit (point)))

