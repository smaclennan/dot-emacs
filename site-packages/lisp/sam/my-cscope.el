;;; my-cscope.el --- Yet another cscope interface... but it is mine.
;; Copyright (C) 2017-2018 Sean MacLennan
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;; For the menu do something like:
;; (add-hook 'c-mode-hook 'my-cscope-setup)

(defgroup my-cscope nil "cscope variables" :group 'tools)

(defcustom my-cscope-prog "cscope" "* The cscope program.")

;; Note: -R has no extra overhead if you have no subdirs
(defcustom my-cscope-args "-R" "* Extra cscope arguments.")

(defcustom my-cscope-dir nil
  "* Directory to start looking for cscope files in.")

(defvar mcs-regexp "^\\([^ ]+\\)\\( [^ ]+ \\)\\([0-9]+\\)"
  "* Regular expression to match filename and line.")

(require 'sam-common)
(require 'compile)
(require 'etags)

(defun mcs-dir ()
  "Find the cscope.out file directory. Use `my-cscope-dir' if
set, else start looking at `default-directory'."
  (let ((dir (if my-cscope-dir my-cscope-dir default-directory)))
    ;; Sanitize the directory
    (setq dir (expand-file-name (file-name-as-directory dir)))
    (catch 'found
      (while (not (equal dir "/"))
	(when (file-exists-p (concat dir "cscope.out"))
	  (throw 'found dir))
	;; This removes the last directory
	(setq dir (file-name-directory (directory-file-name dir))))
      (error "No cscope.out file found."))))

;; SAM DBG try to debug the emacs cscope problems
(defun my-cscope-dbg ()
  (with-output-to-temp-buffer "*my-cscope-dbg*"
    (princ (format "compilation-error-regexp-alist %S\n" compilation-error-regexp-alist))
    (princ (format "compilation-finish-functions %S\n" compilation-finish-functions))
    (princ (format "compilation-locs %S\n" compilation-locs))
    ))

;; Deal with XEmacs vs GNU Emacs differences in compile
(my-feature-cond
  (emacs
   (add-to-list
    'compilation-error-regexp-alist-alist (list 'cscope mcs-regexp 1 3))

   ;; Emacs sets `compilation-locs' so use it
   (defun mcs-cscope-finished (buffer desc)
     (when (equal (buffer-name buffer) "*cscope*")
       (my-cscope-dbg)
       (setq compilation-error-regexp-alist
	     (delq 'cscope compilation-error-regexp-alist))
       (setq compilation-finish-functions
	     (delq 'mcs-cscope-finished compilation-finish-functions))
       (when (eq (hash-table-count compilation-locs) 1)
	 (maphash (lambda (key value)
		    (mcs-goto (car key) (car (nth 2 value))))
		  compilation-locs))))

   (defun mcs-lookup (cmd)
     "Run the cscope command CMD."
     ;; These must be set, let bindings will not work
     (add-to-list 'compilation-error-regexp-alist 'cscope)
     (add-to-list 'compilation-finish-functions 'mcs-cscope-finished)
     (compilation-start cmd nil (lambda (mode) "*cscope*")))
   ) ;; Emacs

  (xemacs
   (defvar mcs-regexp-alist (list (list mcs-regexp 1 3))
     "The regular expression alist used by `my-cscope'. See
`compilation-error-regexp-alist'.")

   (defun mcs-cscope-finished (buffer desc)
     (when (equal (buffer-name buffer) "*cscope*")
       (let (list)
	 (goto-char (point-min))
	 (while (re-search-forward mcs-regexp nil t)
	   (setq list (nconc list
			     (list (list (match-string 1) (match-string 3))))))
	 (goto-char (point-min))
	 (when (eq (length list) 1)
	   (setq list (car list))
	   (mcs-goto (car list) (cadr list))))))

   (defun mcs-lookup (cmd)
     "Run the cscope command CMD."
     (setq compilation-finish-function 'mcs-cscope-finished)
     (compile-internal cmd "No more entries." "cscope" nil mcs-regexp-alist))
   )) ;; XEmacs

(defun mcs-goto (filename line)
  "Goto LINE in FILENAME."
  (when (stringp line) (setq line (string-to-number line)))
  (find-file filename)
  (my-feature-cond
    (emacs (with-no-warnings (goto-line line)))
    (t (goto-line line))))

(defconst mcs-prompts
  '("0 Find this C symbol"
    "1 Find this function definition"
    "2 Find this text string"
    "3 Find functions called by this function"
    "4 Find functions calling this function"
    "5 Change this text string"
    "6 Find this egrep pattern"
    "7 Find this file"
    "8 Find files #including this file"
    "9 Find assignments to this symbol")
  "The prompts for the different cscope commands. If they look
familiar, it is because they come from cscope. They are
re-arranged slightly.")

;;;###autoload
(defun my-cscope (type &optional sym)
  "Call cscope on SYM of type TYPE. Set a prefix arg for TYPE. TYPE
must be 0 to 9 inclusive (see man cscope).

SYM defaults to the current word at the point.

If there is only one result, then `my-cscope' will just goto the
symbol. If there are multiple results, then a compilation buffer
is shown and you can select the result or use `next-error' to go
through the results.

The cscope command run is:
`my-cscope-prog' `my-cscope-args' -L -<TYPE><SYM>."
  (interactive "p")
  (when (or (< type 0) (> type 9))
    (error "invalid type %d: must be 0 to 9 inclusive." type))

  (unless sym
    (let ((word (current-word))
	  (prompt (nth type mcs-prompts)))
      (setq sym (read-string (concat prompt " [" word "]: ") nil nil word))))

  (let ((default-directory (mcs-dir))
	(cmd (concat my-cscope-prog " " my-cscope-args " -L -"
		     (number-to-string type) sym)))
    (push-tag-mark)
    (message cmd)
    (mcs-lookup cmd))
  ;; nil is so GNU Emacs doesn't try to put the results in the minibuffer
  nil)

;;;###autoload
(defun my-cscope-at-point (type)
  "Grab word at point and call `my-cscope'."
  (interactive "p")
  (my-cscope type (current-word)))

(defun my-cscope-setup ()
  "Initialize the cscope menu."
  (unless (boundp 'my-cscope-menu)
    (let ((menu '("Cscope...")))
      (dolist (i (number-sequence 0 9))
	(nconc menu (list (vector (nth i mcs-prompts) (list 'my-cscope i) t))))
      (easy-menu-define my-cscope-menu nil "My Cscope Menu" menu)
      (easy-menu-add-item nil '("C") my-cscope-menu ""))))

(provide 'my-cscope)
